---
title: "Curso introductorio de Shiny"
author: "Carlos M. Lopera-Gómez, Ph.D<br/> Profesor Asociado - Escuela de Estadística<br/> Universidad Nacional de Colombia, Sede Medellín"
date: "Noviembre 8 de 2019"
output:
  ioslides_presentation:
    logo: mis_figuras/logo_transparente.png
    smaller: yes
  beamer_presentation: default
---

[comment1]: <> (install.packages(c("shiny", "maps", "mapproj", "quantmod", "ggplot2")))

# Introducción a Shiny

## Introducción
Shiny es un paquete de R que permite construir aplicaciones web interactivas directamente desde R. Este curso, que está basado en los [Tutoriales Escritos de shiny disponibles en RStudio](https://shiny.rstudio.com/tutorial/), le permitirá comenzar a construir aplicaciones Shiny de forma inmediata.

Si usted aún no ha instalado el paquete shiny, abra una sesión de R y estando conectado a internet ejecute:
```{r, eval = F}
install.packages("shiny")
```

## Ejemplos

El paquete Shiny tiene once ejemplos incorporados que demuestran como funciona.

El primer y más sencillo de los ejemplos es [**Hello Shiny**](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/01_hello/), el cual grafica un histograma del conjunto de datos de R `faithful` con un número de intervalos configurable. El usuario puede cambiar el número de intervalos con una barra deslizante y la aplicación inmediatamente responderá a su entrada. Se usará esta aplicación para explorar la estructura de una aplicación Shiny y para crear una nueva.

Para ejecutar **Hello Shiny**, escriba:
```{r, eval = F}
library(shiny)
runExample("01_hello")
```

## Estructura de una aplicación Shiny

Las aplicaciones Shiny se escriben en un script simple con nombre `app.R`, el cual está dentro de una carpeta, digamos `newdir` y la aplicación se puede ejecutar con `runApp("newdir")`.

`app.R` tiene tres componentes:

* Un objeto de interfaz de usuario
* Una función de servidor
* Una llamada a la función `shinyApp`.

El objeto de interfaz de usuario (`iu`) controla el diseño y la apariencia de la aplicación. La función de servidor (`server`) contiene las instrucciones que el computador necesita para construir la aplicación. Finalmente, la función `shinyApp` crea los objetos de la aplicación Shiny desde el par explícito UI/server.

---

Una buena característica de las aplicaciones de archivo simple es que se puede copiar y pegar la aplicación completa en la consola de R, lo que facilita compartir el código con otros. Por ejemplo, si copia y pega el código que se muestra a continuación, se iniciará la aplicación **Hello Shiny**.

Observe que la función `server` en **Hello Shiny** es muy simple. El script hace algunos cálculos y luego grafica un histograma con el número de intervalos requerido.

Sin embargo, note que la mayoría del código está relacionado a un llamado a la función `renderPlot`. El comentario puesto sobre esta función explica un poco, pero puede ser confuso, no hay por qué preocuparse, ya que este concepto se cubrirá con mayor detalle más adelante.

---

Se puede experimentar con la aplicación **Hello Shiny**, revisar su código fuente e intentar entender como funciona la aplicación. Pero antes de hacer eso, note que un archivo `app.R` necesita cargar el paquete Shiny al inicio y llamar a la función `shinyApp` al final:

```{r, eval = F}
library(shiny)

# See above for the definitions of ui and server
ui <- ...

server <- ...

shinyApp(ui = ui, server = server)
```

Mientras que la aplicación **Hello Shiny** este activa la sesión de R estará ocupada, por lo que no se podrá ejecutar ningún comando R, ya que éste estará monitoreando la aplicación y ejecutando las reacciones de la aplicación. Para recuperar la sesión de R, presione escape o haga clic en el icono de señal de alto (que se encuentra en la esquina superior derecha del panel de la consola en RStudio).

## Ejecutando una aplicación

Toda aplicación Shiny tiene la misma estructura: un archivo `app.R` que contiene a `ui` y a `server`. Se puede crear una aplicación Shiny haciendo una nueva carpeta y guardando un archivo `app.R` en ella. Se recomienda que cada aplicación este alojada dentro de propia carpeta única.

Se puede ejecutar una aplicación Shiny usando el nombre de la carpeta como parámetro de la función `runApp`. Por ejemplo, si una aplicación Shiny está en una carpeta llamada my_app, ejecúte la aplicación con el siguiente código:

```{r, eval = F}
library(shiny)
runApp("my_app")
```

El primer argumento de runApp es la ruta desde el directorio de trabajo a la carpeta de la aplicación. El código anterior asume que la carpeta de la aplicación está en el directorio de trabajo, en cuyo caso la ruta es solo el nombre de la carpeta.

## Ejercicio 1

Cree una nueva carpeta llamada App-1 en el directorio de trabajo. Luego, copie y pegue el script anterior `app.R` dentro de la carpeta (los códigos de [**Hello Shiny**](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/01_hello/)).

Inicie la aplicación ejecutando:
```{r, eval = F}
runApp("App-1")
```

cuyo resultado es [App-1](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/App-1/).

Luego, haga clic en escape y realice algunos cambios en su aplicación:

1. Cambie el título de "Hello Shiny!" A "Hello World!".

2. Establezca el valor mínimo de la barra deslizante en 5.

3. Cambie el color del borde de las barras del histograma de `"white"` a `"orange"`.

Cuando termine, inicie su aplicación nuevamente. El resultado del ejercicio es [App-1-final](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/App-1-final/).

---

Por defecto, las aplicaciones Shiny se muestran en modo "normal", como la aplicación anterior. **Hello Shiny** y los otros ejemplos integrados se muestran en modo "showcase", que muestra el script `app.R` junto con la aplicación.

Si se desea mostrar una aplicación en modo "showcase", se puede ejecutar:
```{r, eval = F}
runApp("App-1", display.mode = "showcase")
```

## Relanzar aplicaciones

Para relanzar una aplicación Shiny:

* Ejecute `runApp("App-1")`, o
* Abra el script `app.R` en el editor de RStudio. RStudio reconocerá el script Shiny y proporcionará un botón **Run App** (en la parte superior del editor). Haga clic en este botón para iniciar su aplicación o use el método abreviado de teclado: Ctrl + Mayús + Entrar (Comando + Mayús + Entrar en Mac).

## Resumen

Para crear su propia aplicación Shiny:

* Cree una carpeta llamada `myapp/` para su aplicación.
* Guarde el script `app.R` dentro de la carpeta.
* Ejecute la aplicación con `runApp` o usando los métodos abreviados de teclado de RStudio.
* Salga de la aplicación Shiny mediante la tecla escape.

## Para complementar
Como se ha visto se pueden crear aplicaciones Shiny copiando y modificando otras aplicaciones Shiny existentes. La [galería de Shiny](https://shiny.rstudio.com/gallery) proporciona algunos buenos ejemplos o se pueden usar los once ejemplos incorporados que se muestran a continuación:
```{r, eval = F}
runExample("01_hello")      # a histogram
runExample("02_text")       # tables and data frames
runExample("03_reactivity") # a reactive expression
runExample("04_mpg")        # global variables
runExample("05_sliders")    # slider bars
runExample("06_tabsets")    # tabbed panels
runExample("07_widgets")    # help text and submit buttons
runExample("08_html")       # Shiny app built from HTML
runExample("09_upload")     # file upload wizard
runExample("10_download")   # file download wizard
runExample("11_timer")      # an automated timer
```

Cada una demuestra una característica de las aplicaciones Shiny. Todas losejemplos de aplicaciones Shiny abren en el modo “showcase” (esto es, mostrando el código en `app.R`).

# Interfaz de usuario `ui`

## Construcción de una `ui`

Esta sección muestra cómo crear una interfaz de usuario para su aplicación.

[//]: # (Para ello se inicia con el diseño de la interfaz de usuario para luego agregar texto, imágenes y otros elementos HTML a su aplicación Shiny.)

Se usará la aplicación `App-1` que fue creada en la sección anterior. Para comenzar, abra su archivo `app.R`. Edite el script para que coincida con el siguiente:
```{r, eval=F}
library(shiny)

# Define UI ----
ui <- fluidPage(
  
)

# Define server logic ----
server <- function(input, output){
  
}

# Run the app ----
shinyApp(ui = ui, server = server)
```

Código mínimo necesario para crear una aplicación Shiny, cuyo resultado es [minimal](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/minimal/).

## Diseño

Shiny usa la función `fluidPage` para crear una pantalla que se ajusta automáticamente a las dimensiones de la ventana del navegador. El diseño de la interfaz de usuario consiste en colocar elementos en la función `fluidPage`.

Por ejemplo, la función `ui` que se muestra a continuación crea una interfaz de usuario que tiene un panel de título y un diseño de barra lateral, que incluye un panel de barra lateral y un panel principal.
```{r, eval=F}
ui <- fluidPage(
  titlePanel("title panel"),

  sidebarLayout(
    sidebarPanel("sidebar panel"),
    mainPanel("main panel")
  )
)
```

cuyo resultado es [ej1](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej1/).

---

Los dos elementos más populares que se adicionan a `fluidPage` son `titlePanel` y `sidebarLayout`, creando una aplicación Shiny con una barra lateral.

`sidebarLayout` tiene dos argumentos `output`:

* La función `sidebarPanel`.
* La función `mainPanel`.

Estas funciones colocan contenido en el panel de la barra lateral o en el panel principal. El panel de la barra lateral aparecerá por defecto en el lado izquierdo de la aplicación. Se puede mover hacia el lado derecho dando el argumento opcional `position = "right"` en `sidebarLayout`.
```{r, eval=F}
ui <- fluidPage(
  titlePanel("title panel"),

  sidebarLayout(position = "right",
                sidebarPanel("sidebar panel"),
                mainPanel("main panel")
  )
)
```

cuyo resultado es [ej2](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej2/).

---

`titlePanel` y `sidebarLayout` crean un diseño básico para la aplicación Shiny, pero también se pueden crear diseños más avanzados.

Se puede usar `navbarPage` para proporcionarle a la aplicación una interfaz de usuario de varias páginas que incluya una barra de navegación. También se puede usar `fluidRow` y `column` para crear un diseño desde un sistema de cuadrícula.

Si desea obtener más información sobre estas opciones avanzadas, lea la [Guía de diseño de aplicaciones Shiny](http://shiny.rstudio.com/articles/layout-guide.html). En este curso se usará `sidebarLayout`.

Se puede agregar contenido a la aplicación Shiny simplemente colocándolo dentro de una función `*Panel`. Por ejemplo, la aplicación [ej2](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej2/) muestra una cadena de caracteres en cada uno de sus paneles. Las palabras "sidebar panel" aparecen en el panel de la barra lateral, debido a que éstas se agregaron en la función `sidebarPanel`, esto es, `sidebarPanel("sidebar panel")`. Lo mismo se hizo para el texto en el panel de título y el panel principal.

## Contenido HTML

Para agregar contenido más avanzado, se usan las funciones etiqueta HTML de Shiny. Estas funciones son paralelas a las etiquetas HTML5 comunes. Veamos algunas de ellas.

**shiny function** | **HTML5 equivalent** | **creates**
------------------ | -------------------- | ----------------------
p | `<p>` | A paragraph of text
h1 | `<h1>` | A first level header
h2 | `<h2>` | A second level header
h3 | `<h3>` | A third level header
h4 | `<h4>` | A fourth level header
h5 | `<h5>` | A fifth level header
h6 | `<h6>` | A sixth level header

---

**shiny function** | **HTML5 equivalent** | **creates**
------------------ | -------------------- | ----------------------
a | `<a>` | A hyper link
br | `<br>` | A line break (e.g. a blank line)
div | `<div>` | A division of text with a uniform style
span | `<span>` | An in-line division of text with a uniform style
pre | `<pre>` | Text ‘as is’ in a fixed width font
code | `<code>` | A formatted block of code
img | `<img>` | An image
strong | `<strong>` | Bold text
em | `<em>` | Italicized text
HTML |	|	Directly passes a character string as HTML code

## Encabezados

Para crear un elemento de encabezado:

* Seleccionar una función de encabezado (por ejemplo, h1 o h5)
* Asignar el texto que desea ver en el encabezado

Por ejemplo, puede crear un encabezado de primer nivel que diga "My title" con `h1("My title")`. Si este comando se ejecuta en la consola de R producirá código HTML.
```{r, eval = F}
library(shiny)
h1("My title")
```
```{r, echo = F, comment=NA}
cat("<h1>My title</h1>")
```

Para colocar el comando en la aplicación:

* Coloque `h1("My title")` como argumento en `titlePanel`, `sidebarPanel` o `mainPanel`.

El texto aparecerá en el panel correspondiente de su página web.

---

Se pueden colocar varios elementos en el mismo panel si los separa con una coma. Por ejemplo, el código que se muestra a continuación utiliza los seis niveles de encabezados.
```{r, eval=F}
ui <- fluidPage(
  titlePanel("My Shiny App"),
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      h1("First level title"),
      h2("Second level title"),
      h3("Third level title"),
      h4("Fourth level title"),
      h5("Fifth level title"),
      h6("Sixth level title")
    )
  )
)
```

cuyo resultado es [ej3](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej3/).

---

Se pueden crear efectos en las etiquetas HTML, por ejemplo, si se quiere centrar un título se puede usar el argumento `align = "center"` en el correspondiente encabezado, digamos h1("First level title", align = "center").

En general, cualquier atributo de etiqueta HTML se puede establecer como argumento en cualquier función de etiqueta Shiny. Si no está familiarizado con los atributos de etiqueta HTML, puede buscarlos en uno de los muchos recursos HTML gratuitos en línea, como [w3schools](http://www.w3schools.com/tags/tag_hn.asp). A continuación se muestra el código para el objeto `ui` inspirado en Star Wars:
```{r, eval=F}
ui <- fluidPage(
  titlePanel("My Star Wars App"),
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      h6("Episode IV", align = "center"),
      h6("A NEW HOPE", align = "center"),
      h5("It is a period of civil war.", align = "center"),
      h4("Rebel spaceships, striking", align = "center"),
      h3("from a hidden base, have won", align = "center"),
      h2("their first victory against the", align = "center"),
      h1("evil Galactic Empire.", align = "center")
    )
  )
)
```

cuyo resultado es [ej4](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej4/).

## Texto con formato

Shiny ofrece muchas funciones `tag` para formatear texto. Para ilustrar esto, pegue el siguiente objeto `ui` en su archivo `app.R` y guárdelo. El resultado es [ej5](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej5/).
```{r, eval=F}
ui <- fluidPage(
  titlePanel("My Shiny App"),
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      p("p creates a paragraph of text."),
      p("A new p() command starts a new paragraph. Supply a style attribute to change
        the format of the entire paragraph.", 
        style = "font-family: 'times'; font-si16pt"),
      strong("strong() makes bold text."),
      em("em() creates italicized (i.e, emphasized) text."),
      br(),
      code("code displays your text similar to computer code"),
      div("div creates segments of text with a similar style. This division of text
          is all blue because I passed the argument 'style = color:blue' to div",
          style = "color:blue"),
      br(),
      p("span does the same thing as div, but it works with",
        span("groups of words", style = "color:blue"),
        "that appear inside a paragraph.")
    )
  )
)
```

## Imágenes

Las imágenes pueden mejorar la apariencia de una aplicación y ayudar a los usuarios a comprender el contenido. Shiny usa la función `img` para colocar archivos de imagen en su aplicación.

Para insertar una imagen, asigne a la función `img` el nombre del archivo de imagen como un argumento `src` (por ejemplo, `img(src = "my_image.png")`). También se pueden incluir otros parámetros compatibles con HTML, tales como *height* y *width*. Tenga en cuenta que los valores para *height* y *width* se referirán a píxeles.
```{r, eval=F}
img (src = "my_image.png", height = 72, width = 72)
```

La función `img` busca el archivo de imagen en un lugar específico. El archivo debe estar en una carpeta llamada `www` en el mismo directorio que el archivo `app.R`. Shiny trata este directorio de una manera especial, compartiendo cualquier archivo colocado allí con el navegador, lo que hace de `www` un excelente lugar para colocar imágenes, hojas de estilo y otras cosas que el navegador necesitará para construir los componentes wep de su aplicación Shiny.

---

Por ejemplo, el siguiente objeto `ui` puede crear esta aplicación. Descargue la imagen [R_day](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej5/www/R_day.png) y úsela con el siguiente código:
```{r, eval=F}
ui <- fluidPage(
  titlePanel("My Shiny App"),
  sidebarLayout(
    sidebarPanel(),
    mainPanel(
      img(src = "rstudio.png", height = 140, width = 140)
    )
  )
)
```

cuyo resultado es [ej6](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/ej6/).

Para obtener mayor información sobre las funciones etiquetas adicionales consulte [Personalice su IU con HTML](https://shiny.rstudio.com/articles/html-tags.html) y [Glosario de etiquetas HTML de Shiny](https://shiny.rstudio.com/articles/tag-glossary.html).

## Resumen

Con las habilidades presentadas, puede:

* Crear una interfaz de usuario con `fluidPage`, `titlePanel` y `sidebarLayout`.
* Crear un elemento HTML con una de las funciones etiqueta de Shiny.
* Establecer atributos de etiqueta HTML en los argumentos de cada función etiqueta.
* Agregar un elemento a su aplicación colocándola en `titlePanel`, `sidebarPanel` o `mainPanel`.
* Agregar múltiples elementos a cada panel separándolos con una coma
* Agregar imágenes colocándolas en la carpeta `www` dentro del directorio de la aplicación Shiny y luego llamando a la función `img`.

# Agregar widgets de control

## ¿Qué es un widget?

Un widget es un elemento web con el que sus usuarios pueden interactuar. Los widgets proporcionan una forma en que los usuarios pueden enviar mensajes a una aplicación Shiny.

Los widgets de Shiny recopilan valores de usuario. Cuando el usuario cambia el widget, también lo hace su valor. Esto permite oportunidades que se explorarán más adelante.

## Widgets de control 

Shiny viene con una familia de widgets incorporados, cada uno creado con una función R. Por ejemplo, Shiny proporciona una función llamada `actionButton` que crea un Botón de acción y una función llamada `sliderInput` que crea una barra deslizante.

Los widgets Shiny estándar son:

Función | Widget
--- | ---
`actionButton` | Botón de acción
`checkboxGroupInput` | Un grupo de casillas de verificación
`checkboxInput` | Una sola casilla de verificación
`dateInput` | Un calendario para selección de una fecha
`dateRangeInput` | Un par de calendarios para seleccionar un rango de fechas
`fileInput` | Un asistente de control para la carga de archivos

---

Función | Widget
--- | ---
`helpText` | Texto de ayuda que se puede agregar a un formulario de entrada
`numericInput` | Un campo para ingresar números
`radioButtons` | Un conjunto de botones para selección múltiple de única respuesta
`selectInput` | Un cuadro con opciones para seleccionar
`sliderInput` | Una barra deslizante
`submitButton` | Un botón de enviar
`textInput` | Un campo para ingresar texto

## Agregar widgets

Se pueden agregar widgets a la aplicación de la misma manera que se agregaron otros tipos de contenido HTML en la sección anterior. Para agregar un widget a la aplicación, coloque una función widget en `sidebarPanel` o `mainPanel` dentro del objeto `ui`.

Cada función widget requiere varios argumentos. Los primeros dos argumentos para cada widget son:

* Un **nombre para el widget**: el usuario no verá este nombre, pero puede usarlo para acceder al valor del widget. El nombre debe ser una cadena de caracteres.
* Una **etiqueta**: esta etiqueta aparecerá con el widget en la aplicación. Debe ser una cadena de caracteres, pero puede ser una cadena vacía `""`.

Por ejemplo, para crear un botón de acción cuyo nombre es "action" y su etiqueta es "Action" se usa el código: `actionButton ("action", label = "Action")`

---

Los argumentos restantes varían de un widget a otro, dependiendo de lo que el widget necesite para hacer el trabajo. Éstos pueden ser valores iniciales, rangos e incrementos. Se pueden consultar los argumentos exactos que necesita un widget en la página de ayuda de la función widget (por ejemplo: `?selectInput`).

La aplicación [widgets](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/widgets/) muestra los diferentes widgets disponibles.

Una buena manera de tener una idea del funcionamiento de cada widget es experimentar cambiando los valores de las funciones widget y observar los efectos. Par mayores detalles sobre el diseño de esta aplicación Shiny, puede leer la descripción en la [Guía de diseño de la aplicación](https://shiny.rstudio.com/articles/layout-guide.html).

## Resumen

Es fácil agregar widgets completamente funcionales a una aplicación Shiny.

* Shiny proporciona una familia de funciones para crear estos widgets.
* Cada función requiere un nombre y una etiqueta.
* Algunos widgets necesitan instrucciones específicas para hacer su trabajo.
* Para agregar widgets a una aplicación Shiny se procede igual que para agregar otros tipos de contenido HTML (ver sección anterior).

## Para complementar

La [Galería de Widgets de Shiny](http://shiny.rstudio.com/gallery/widget-gallery.html) proporciona plantillas en donde se muestra cada uno de los widgets de Shiny y cómo cambian los valores de éstos en respuesta a la entrada.

Seleccione el widget que desee y haga clic en el botón "See code" debajo del widget. La galería lo llevará a una aplicación de ejemplo que describe el widget. Para usarlo, copie y pegue el código desde el archivo de ejemplo en su archivo `app.R`.

En la siguiente sección, aprenderá cómo conectar widgets con una salida reactiva, que son objetos que se actualizan cada vez que el usuario cambia un widget.

# Salida reactiva

## Mostrar salida reactiva

Esta sección muestra cómo construir una salida reactiva para mostrar en la aplicación Shiny. Una salida reactiva responde automáticamente cuando un usuario varía el valor de un widget.

Al final de esta sección, se debe estar en capacidad de hacer una aplicación Shiny simple con dos líneas de texto reactivas. Cada línea mostrará los valores de un widget en función de la entrada del usuario.

Para esta nueva aplicación Shiny, se debe crear una carpeta en el directorio de trabajo llamada `census-app`, donde se guardará el archivo app.R que se usará en esta sección.

## Dos pasos

Se pueden crear resultados reactivos en un proceso de dos pasos.

* Agregar un objeto R a la interfaz de usuario.
* Indicar a Shiny cómo construir el objeto en la función `server`. El objeto será reactivo si el código que lo construye usa el valor de un widget.

### Paso 1: Agregar un objeto R a la IU

Shiny proporciona una familia de funciones que convierten los objetos R en salida para la interfaz de usuario. Cada función crea un tipo específico de salida.

Función Output | Crea
--- | ---
tableOutput, dataTableOutput | Tabla, Tabla de datos
plotOutput, imageOutput | Gráfico, Imagen
textOutput, verbatimTextOutput | Texto
htmlOutput, uiOutput | HTML sin formato

---

Se pueden agregar resultados a la `ui` de la misma manera que se agregaron elementos HTML y widgets, esto es, dentro de `sidebarPanel` o `mainPanel`. Por ejemplo, el siguiente código usa `textOutput` para agregar una línea de texto reactiva al panel principal de la aplicación Shiny.
```{r, eval=F}
ui <- fluidPage(
  titlePanel("censusVis"),
  
  sidebarLayout(
    sidebarPanel(
      helpText("Create demographic maps with information from the 2010 US Census."),
      
      selectInput("var", 
                  label = "Choose a variable to display",
                  choices = c("Percent White", "Percent Black",
                              "Percent Hispanic", "Percent Asian"),
                  selected = "Percent White"),
      
      sliderInput("range", label = "Range of interest:",
                  min = 0, max = 100, value = c(0, 100))
    ),
    
    mainPanel(
      textOutput("selected_var")
    )
  )
)
```

---

### Paso 2: Proporcionar el código R para construir el objeto.

Para hacer esto se debe proporcionar el código R que construye el objeto en la función `server`que construye un objeto `output` tipo lista que contiene todo el código necesario para actualizar los objetos R de la aplicación. Cada objeto R necesita tener su propia entrada en la lista. El nombre del elemento debe coincidir con el nombre del elemento reactivo que se creó en la `ui`.

En la siguiente función `server`, el objeto `output$selected_var` coincide con `textOutput("selected_var")` en la `iu`.
```{r, eval=F}
server <- function(input, output){
  
  output$selected_var <- renderText({
    "You have selected this"
  })
  
}
```
La aplicación `census-app` con el `ui` y `server` antes definidos se muestra en [census-app](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/census-app/).

---

Cada entrada en el objeto `output` debería contener la salida de una de las funciones `render*` de Shiny. Estas funciones capturan una expresión R y realizan un ligero preprocesamiento en la expresión. Se debe usar la función `render*` que corresponde al tipo de objeto reactivo que se está creando. 

Función render | crea
--- | ---
`renderDataTable` | Tabla de datos
`RenderImage` | Imágenes (guardadas como un enlace a un archivo fuente)
`renderPlot` | Gráfica
`renderPrint` | Cualquier salida impresa
`renderTable` | Marco de datos, matriz u otras estructuras similares a tablas
`renderText` | Cadenas de caracteres
`renderUI` | Un objeto etiqueta de Shiny o HTML

<br/>
Cada función `render*` tiene un solo argumento: una expresión R entre llaves, `{}`. La expresión puede ser una simple línea de texto, o puede involucrar muchas líneas de código.

---

Piense en tal expresión R como un conjunto de instrucciones que se guardan en Shiny para más tarde. Shiny ejecutará las instrucciones la primera vez que se inicie la aplicación, y las volverá a ejecutar cada vez que se necesite actualizar el objeto.

Para que esto funcione, la expresión debe devolver el objeto que se tiene en mente (un fragmento de texto, un gráfico, un marco de datos, etc.), si esto no ocurre, es decir, si la expresión no devuelve un objeto, o si devuelve un tipo de objeto incorrecto, se obtendrá un error.

### Uso de valores de un widget

Al ejecutar la aplicación con la anterior función `server`, mostrará "You have selected this" en el panel principal. Sin embargo, el texto no será reactivo, es decir, no cambiará incluso si manipula los widgets de la aplicación. Para hacerlo reactivo se le debe pedir a Shiny que llame a un valor de widget cuando construye el texto.

Note que la función `server` menciona dos argumentos, `input` y `output`. Se sabe que `output` es un objeto tipo lista que almacena las instrucciones para construir los objetos R en la aplicación. El objeto `input` es un segundo objeto tipo lista que almacena los valores actuales de todos los widgets en la aplicación.

Observe que, la aplicación tiene dos widgets en la `ui`, uno llamado `"var"` y otro llamado `"range"`. Los valores de `"var"` y `"range"` se guardarán en el objeto `input` como `input$var` e `input$range`. Como el control deslizante tiene dos valores (un mínimo y un máximo), el objeto `input$range` contendrá un vector de longitud dos.

---

Shiny automáticamente hace que un objeto sea reactivo si éste usa un valor de un objeto `input`. Por ejemplo, la siguiente función `server` crea una línea de texto reactiva llamando al valor del widget del cuadro de selección para generar el texto.
```{r, eval=F}
server <- function(input, output) {
  
  output$selected_var <- renderText({ 
    paste("You have selected", input$var)
  })
  
}
```

cuyo resultado es [census-app2](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/census-app2/).

Shiny monitorea que salidas dependen de cuales widgets. Cuando un usuario cambia un widget, Shiny reconstruirá todas las salidas que dependen del widget, utilizando el nuevo valor del widget a medida que avanza. Como resultado, los objetos reconstruidos estarán completamente actualizados. 

Así es como se crea la reactividad con Shiny, conectando los valores de objetos `input` a los objetos en `output`. Shiny se encarga de todos los demás detalles.

## Ejercicio 2

Agregue una segunda línea de texto reactivo al panel principal de la aplicación Shiny, que muestre "You have chosen a range that goes from ... to ...", y los "..." deben mostrar los valores mínimo (min) y máximo (max) actual del widget de barra deslizante.

No olvide que debe actualizar tanto el objeto `ui` como la función `server`.

Una solución al problema es [census-app3](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/census-app3/).

## Resumen

En esta sección, se creó la primera aplicación Shiny reactiva. En el camino, se aprendió a

* Usar una función `*Output` en la `ui` para colocar objetos reactivos en la aplicación Shiny.
* Usar una función `render*` en el `server` para indicarle a Shiny cómo construir los objetos.
* Encerrar las expresiones R con llaves, `{}`, en cada función `render*`.
* Guardar las expresiones `render*` en la lista `output`, con una entrada para cada objeto reactivo en la aplicación.
* Crear la reactividad al incluir un valor `input` en una expresión `render*`.

Si se siguen estas reglas, Shiny hará que los objetos sean reactivos automáticamente.

En la siguiente sección se creará una aplicación reactiva más sofisticada que se basa en scripts de R y datos externos.

# Scripts de R y datos

## Uso de scripts de R y datos

Esta sección muestra cómo cargar datos, scripts de R y paquetes para ser usados en las aplicaciones Shiny. En el camino, se creará una aplicación sofisticada que visualiza los datos del censo de EE.UU.

### counties.rds

`counties.rds` es un conjunto de datos de datos demográficos para cada condado de los Estados Unidos, recopilados en el paquete de R `UScensus2010`, el cual se puede descargar [aquí](https://shiny.rstudio.com/tutorial/written-tutorial/lesson5/census-app/data/counties.rds). Una vez descargado,

* Cree una nueva carpeta `data` en el directorio de la aplicación `census-app`.
* Mueva el archivo `counties.rds` a la carpeta `data`.

---

El conjunto de datos `counties.rds` contiene

* El nombre de cada condado de los Estados Unidos.
* La población total del condado.
* El porcentaje de residentes en el condado que son blancos, negros, hispanos o asiáticos.

```{r, comment=NA}
counties <- readRDS("census-app/data/counties.rds")
head(counties)
```

---

### helpers.R
`helpers.R` es un script de R que puede ayudar a hacer [mapas coropléticos](https://es.wikipedia.org/wiki/Mapa_coroplético), que son mapas que usan colores para mostrar la variación regional de una variable. En nuestro caso, `helpers.R` creará `percent_map`, una función diseñada para mapear los datos en `counties.rds`. el script `helpers.R` se puede descargar [aquí](https://shiny.rstudio.com/tutorial/written-tutorial/lesson5/census-app/helpers.R).

`helpers.R` usa los paquetes de R `maps` y `mapproj`. Si nunca antes ha instalado estos paquetes, deberá hacerlo antes de crear esta aplicación. Para ello, ejecute:
```{r, eval=F}
install.packages(c ("maps", "mapproj"))
```
Guarde el archivo `helpers.R` dentro de la carpeta census-app.

---

La función `percent_map` en `helpers.R` usa cinco argumentos:

Argumento | Entrada
--- | ---
var | Un vector columna del conjunto de datos `counties.rds`
color | Cualquier cadena de caracteres entre las opciones de color en `colors()`
legend.title | Una cadena de caracteres para usar como título de la leyenda del gráfico
max | Un parámetro para controlar el rango de sombra (con valor predeterminado de 100)
min | Un parámetro para controlar el rango de sombra (con valor predeterminado de 0)

---

Se puede usar `percent_map` desde la línea de comandos para graficar los datos de los condados como un mapa coroplético, de la siguiente forma:
```{r, comment=F}
library(maps)
library(mapproj)
source("census-app/helpers.R")
counties <- readRDS("census-app/data/counties.rds")
percent_map(counties$white, "darkgreen", "% White")
```

`percent_map` grafica los datos de los condados como un mapa coroplético, donde se gráfica el porcentaje de residentes blancos en los condados de color verde oscuro.

## Cargando archivos y rutas de archivos

Note que para usar `percent_map`

* Se ejecuta `helpers.R` con la función `source`.
* Se carga `counties.rds` con la función `readRDS`.
* Se cargaron los paquetes de R necesarios usando `library(maps)` y `library(mapproj)`.

En Shiny las funcions `source` y `readRDS` no se comportan de la misma manera que en la línea de comandos, ya que Shiny toma las rutas de los archivos como si comenzaran en el mismo directorio del archivo `app.R`.

Luego, las instrucciones en shiny son:

* `source("helpers.R")`. 
* `readRDS ("data/counties.rds")`.
* Los paquetes `maps` y `mapproj` se pueden cargar de la manera usual:
   + library(maps)
   + library(mapproj) 

## Ejecución y sus efectos

Shiny ejecuta todos los comandos si son colocados en el script `app.R`, y el lugar donde se colocan determina cuántas veces se ejecutan (o se vuelven a ejecutar).

* Shiny ejecutará todo el script la primera vez que se llama `runApp`.
* La función `shinyApp` se ejecuta una vez, cuando se inicia la aplicación.
* La función `server` se ejecuta una vez cada vez que un usuario visita la aplicación.
* Las expresiones R dentro de las funciones `render*` se ejecutan cada vez que un usuario cambia el valor de un widget.

De manera que,

* La carga de datos, scripts y paquetes se debe hacer al comienzo del archivo `app.R` por fuera de la función `server`.
* Los objetos específicos de usuario se deben definir dentro de la función `server`, pero por fuera de las llamadas `render*`.
* Dentro de la función `render*` se debe colocar el código que se requiere para volver a construir un objeto. Colocar código innecesario dentro de una función `render` ralentizará la aplicación.

---

La aplicación de visualización del censo tiene un objeto reactivo, que es un gráfico de nombre `"map"`, que se define en el panel principal de la `ui`, así:
```{r, eval=F}
ui <- fluidPage(
  titlePanel("censusVis"),
  
  sidebarLayout(
    sidebarPanel(
      ... # this defined like before
    ),
    
    mainPanel(plotOutput("map"))
  )
)
```

En la función `server` el gráfico se construye con la función `percent_map`, así:
```{r, eval=F}
server <- function(input, output) {
  output$map <- renderPlot({
    percent_map( # some arguments )
  })
}
```

---

La función `percent_map` tiene cinco argumentos:

* Los tres primeros argumentos: `var`, `color` y `legend.title`, dependen del valor del widget del cuadro de selección.
* Los dos argumentos restantes: `max` y `min`, deberían ser los valores máximo y mínimo del widget de barra deslizante. 

La siguiente función `server` muestra una forma de elaborar los argumentos reactivos para `percent_map`. La función `switch` de R puede transformar la salida de un widget de cuadro de selección a lo que se desee.
```{r, eval=F}
server <- function(input, output) {
  output$map <- renderPlot({
    data <- switch(input$var, 
                   "Percent White" = counties$white,
                   "Percent Black" = counties$black,
                   "Percent Hispanic" = counties$hispanic,
                   "Percent Asian" = counties$asian)
    
    percent_map(var = data, color = ?, legend.title = ?, max = ?, min = ?)
  })
}
```

Sin embargo, el código está incompleto, ya que no proporciona valores para `color`, `legend.title`, `max` o `min`.

## Ejercicio 3

1. Abra el archivo `app.R` en la carpeta `census-app4` y agregue los comandos `source("helpers.R")`, `counties <- readRDS("data/counties.rds")`, `library(maps)` y `library(mapproj)`.

Asegúrese de colocar los comandos en una ubicación eficiente.

2. Complete el código para crear una aplicación de visualización del censo que funcione.

Se debe decidir:

* Cómo crear los valores de los argumentos `percent_map`, y
* Dónde colocar el código que crea estos argumentos.

Recuerde, se desea que los valores de argumento cambien cada vez que un usuario cambie el widget asociado.

Una solución al ejercicio es [census-app-final](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/census-app-final/).

## Resumen

Se pueden crear aplicaciones Shiny más complejas cargando conjuntos de datos, scripts y paquetes de R. Tenga en cuenta:

* El directorio en el que aparece `app.R` se convertirá en el directorio de trabajo de la aplicación Shiny.
* Shiny ejecutará el código colocado al inicio de `app.R`, antes de la función `server`, solo una vez durante la ejecución de una aplicación.
* Shiny ejecutará el código colocado dentro de la función `server` varias veces, lo que puede ralentizar la aplicación.

También se aprendió que la función `switch` es útil para acompañar a los widgets de Shiny de opción múltiple. Use `switch` para cambiar los valores de un widget por expresiones R.

A medida que las aplicaciones se tornan más complejas, se pueden volver ineficientes y lentas. La siguiente sección mostrará cómo crear aplicaciones rápidas y modulares con expresiones reactivas.

# Expresiones reactivas

## Uso de expresiones reactivas

Los usuarios buscan que las aplicaciones Shiny sean rápidas (casi instantáneas). Esta sección muestra cómo optimizar las aplicaciones Shiny con expresiones reactivas, las cuales permiten controlar cuales partes de la aplicación se actualizan y cuando, evitando cálculos innecesarios que pueden ralentizar la aplicación.

Para comenzar:

* Cree una nueva carpeta llamada `stockVis` en el directorio de trabajo.
* Descargue los siguientes archivos y colóquelos dentro del directorio `stockVis`: [app.R](https://shiny.rstudio.com/tutorial/written-tutorial/lesson6/stockVis/app.R) y [helpers.R](https://shiny.rstudio.com/tutorial/written-tutorial/lesson6/stockVis/helpers.R).

StockVis utiliza el paquete `quantmod` de R, por lo que se debe usar:
```{r, eval=F}
install.packages("quantmod")
```
* Inicie la aplicación con `runApp("stockVis")`.
```{r, eval=F}
runApp("stockVis")
```

cuyo resultado es [stockVis](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/stockVis/).

## Una nueva aplicación: stockVis

La aplicación `stockVis` busca los precios de acciones para un símbolo de cotización y muestra los resultados como un gráfico de líneas. La aplicación permite:

* Seleccionar una acción para ser examinada,
* Elegir un rango de fechas para revisar,
* Elegir si desea graficar en el eje $y$ los precios de las acciones o el logaritmo de los precios de las acciones, y
* Decidir si se ajustan o no los precios por la inflación.

Note que la casilla de verificación "Adjust prices for inflation" aún no funciona. Una de las tareas en esta sección es corregir el funcionamiento de tal casilla de verificación.

---

Por defecto, `stockVis` muestra las acciones para el símbolo de cotización SPY (un índice del S&P 500 completo). Para buscar una acción diferente se debe ingresar un símbolo de acciones que sea reconocido por **Yahoo Finance**. Los símbolos de acciones de Yahoo se pueden consultar [aquí](https://finance.yahoo.com/lookup/). Algunos símbolos comunes son GOOG (Google), AAPL (Apple) y GS (Goldman Sachs).

`stockVis` depende en gran medida de dos funciones del paquete quantmod:

1. Utiliza `getSymbols` para descargar los datos financieros directamente a R desde sitios web tales como [Yahoo finance](https://finance.yahoo.com/) y el [Banco de la Reserva Federal de St. Louis](http://research.stlouisfed.org/fred2/).
2. Utiliza `chartSeries` para mostrar los precios en un gráfico atractivo.

`stockVis` también se basa en un script R llamado `helpers.R`, que contiene una función que ajusta los precios de las acciones por la inflación.

---

### Casillas de verificación y rangos de fechas

La aplicación `stockVis` utiliza algunos widgets nuevos.

* Un selector de rango de fechas, creado con `dateRangeInput`, y
* Un par de casillas de verificación hechas con `checkboxInput`. Los widgets de casillas de verificación son muy simples, devuelven `TRUE` cuando la casilla de verificación está marcada, y `FALSE` cuando la casilla de verificación no está marcada.

Las casillas de verificación se denominan `log` y `adjust` en el objeto `ui`, lo que significa que se puede buscar como `input$log` e `input$adjust` en la función `server`.

## Simplificar los cálculos

La aplicación `stockVis` tiene un problema.

Observe que cuando se da clic en "Plot y axis on the log scale", el valor de `input$log` cambia y se vuelva a ejecutar la expresión en `renderPlot`:
```{r, eval=F}
output$plot <- renderPlot({
  data <- getSymbols(input$symb, src = "yahoo",
                     from = input$dates[1],
                     to = input$dates[2],
                     auto.assign = FALSE)
  
  chartSeries(data, theme = chartTheme ("white"),
              type = "line", log.scale = input$log, TA = NULL)
  
})
```

Lo cual: 1. Extrae de nuevo los datos de Yahoo Finance con `getSymbols`, y 2. Vuelve a dibujar el gráfico con el eje correcto.

Esto no es bueno, ya que no es necesario volver a ejecutar `getSymbols` para extraer los datos y volver a dibujar el gráfico. Esto puede ralentizar su aplicación y consumir ancho de banda del servidor.

## Expresiones reactivas

Una expresión reactiva es una expresión R que utiliza una entrada de widget y devuelve un valor. La expresión reactiva actualizará este valor cada vez que el widget original cambie. Esto puede limitar lo que se vuelve a ejecutar durante una reacción con expresiones reactivas.

Para crear una expresión reactiva, se usa la función `reactive`, la cual toma una expresión R rodeada de llaves (al igual que las funciones `render*`). Por ejemplo, una expresión reactiva que utiliza los widgets de `stockVis` para extraer los datos de Yahoo.
```{r, eval=F}
dataInput <- reactive({
  getSymbols(input$symb, src = "yahoo",
             from = input$dates[1],
             to = input$dates[2],
             auto.assign = FALSE)
})
```

---

Cuando se ejecuta esta expresión, se ejecutará `getSymbols` y devolverá un marco de datos de precios. Luego, se puede usar esta expresión para acceder a los datos de precios en `renderPlot` llamando a `dataInput()`.
```{r, eval=F}
output$plot <- renderPlot({
  chartSeries(dataInput(), theme = chartTheme("white"),
              type = "line", log.scale = input$log, TA = NULL)
})
```

* Una expresión reactiva guarda su resultado la primera vez que lo ejecuta.
* La próxima vez que se llame a una expresión reactiva, ésta verificará si el valor guardado ha quedado desactualizado (es decir, si los widgets de los que depende han cambiado).
* Si el valor no está actualizado, la expresión reactiva lo volverá a calcular (y guardará el nuevo resultado).
* Si el valor está actualizado, la expresión reactiva devolverá el valor guardado sin realizar ningún cálculo.

Se puede usar este comportamiento para evitar que Shiny vuelva a ejecutar código innecesariamente.

---

Considere cómo funcionará una expresión reactiva en la nueva aplicación `stockVis` a continuación. El resultado es [stockVis2](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/stockVis2/).
```{r}
server <- function(input, output){
  
  dataInput <- reactive({
    getSymbols(input$symb, src = "yahoo",
               from = input$dates[1],
               to = input$dates[2],
               auto.assign = FALSE)
  })
  
  output$plot <- renderPlot({
    
    chartSeries(dataInput(), theme = chartTheme ("white"),
                type = "line", log.scale = input $ log, TA = NULL)
  })

}
```

---

Cuando se hace clic en "Plot y axis on the log scale", `input$log` cambiará y `renderPlot` se volverá a ejecutar.

Ahora:

1. `renderPlot` llamará a `dataInput()`
2. `dataInput` verificará que los widgets `dates` y `symb` no hayan cambiado
3. `dataInput` devolverá el conjunto de datos guardados de precios de acciones sin volver a extraer los datos desde Yahoo.
4. `renderPlot` volverá a dibujar el gráfico con el eje correcto.

## Dependencias

Suponga que el usuario cambia el símbolo de acciones en el widget `symb`. Esto hará que el gráfico dibujado por `renderPlot` esté desactualizado, pero `renderPlot` no llama directamente a `input$symb`.

Note que, Shiny de todas formas detecta que `input$symb` ha desactualizado el gráfico y volverá a dibujarlo, esto ocurre porque Shiny monitorea las dependencias de las expresiones reactivas tanto de los objetos `output` como de los valores `input`.

Shiny reconstruye automáticamente un objeto si:

* Un valor `input` en la función `render*` de los objetos cambia, o
* Una expresión reactiva en la función `render*` de los objetos se vuelve obsoleta.

Las expresiones reactivas son como enlaces en una cadena que conectan los valores `input` a los objetos `output`. Los objetos `output` responden a los cambios realizados en cualquier parte de la cadena.

Se recomienda llamar a una expresión reactiva desde adentro de una función `reactive` o `render*`, debido a que solo estas funciones de R pueden manejar una salida reactiva

---

### Casilla de verificación "Adjust prices for inflation"

La función `adjust` en `helpers.R` utiliza los datos del [índice de precios al consumidor](http://research.stlouisfed.org/fred2/series/CPIAUCNS) proporcionados por el Banco de la Reserva Federal de St. Louis para transformar los precios históricos en valores actuales.

Una solución, que no es la ideal se presenta a continuación. El resultado es [stockVis3](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/stockVis3/).
```{r, eval=F}
server <- function(input, output){
  
  dataInput <- reactive({
    getSymbols(input$symb, src = "yahoo",
               from = input$dates[1],
               to = input$dates[2],
               auto.assign = FALSE)
  })
  
  output$plot <- renderPlot({
    data <- dataInput()
    if(input$adjust) data <- adjust(dataInput())
    
    chartSeries(data, theme = chartTheme("white"),
                type = "line ", log.scale = input$log, TA = NULL)
  })
}
```

## Ejercicio 4

Solucione el problema anterior agregando una nueva expresión reactiva a la aplicación. La expresión reactiva debe tomar el valor de `dataInput` y devolver una copia ajustada (o no ajustada) de los datos.

Asegúrese de entender qué cálculos se hacen o no en la aplicación, cuando se hace clic en "Plot y axis on the log scale".

La solución al ejercicio es [stockVis-final](http://gauss.medellin.unal.edu.co:3838/cmlopera/R_day/stockVis-final/)

## Resumen

Se pueden acelerar las aplicaciones modularizando el código con expresiones reactivas

* Una expresión reactiva toma valores `input`, o valores de otras expresiones reactivas, y devuelve un nuevo valor.
* Las expresiones reactivas guardan los resultados, y solo los volverán a calcular si la entrada ha cambiado.
* Crear las expresiones reactivas con `reactive({ })`.
* Llamar las expresiones reactivas con el nombre de la expresión seguido de paréntesis `()`.
* Solo llame a las expresiones reactivas desde adentro de otras expresiones reactivas o funciones `render*`.

Ahora puede crear aplicaciones Shiny sofisticadas y optimizadas. La sección final de este curso muestra cómo compartir las aplicaciones con otros.

# Compartir las aplicaciones

## Compartir las aplicaciones

Esta sección muestra varias formas de compartir las aplicaciones Shiny, para lo cual se tienen dos opciones básicas:

* **Compartir la aplicación Shiny como un script de R**. Esta es la forma más sencilla de compartir una aplicación, pero solo funciona si los usuarios tienen R en su computadora (y saben cómo usarlo). Los usuarios pueden usar estos scripts para iniciar la aplicación desde una sesión R.

* **Compartir la aplicación Shiny como una página web**. Esta es definitivamente la forma más amigable de compartir una aplicación Shiny. Los usuarios pueden acceder a la aplicación a través de internet desde un navegador. La aplicación estará totalmente procesada, actualizada y lista para funcionar.

## Compartir como un script de R

En este caso cualquier usuario, que tenga copia del archivo `app.R` y el material complementario utilizado por la aplicación (por ejemplo, carpetas `www` o archivos `helpers.R`), puede ejecutar la aplicación Shiny.

Para enviar los archivos a otro usuario, puede hacerlo por correo electrónico (tal vez en un archivo zip) o alojar los archivos en línea. El usuario puede colocar los archivos en una carpeta en el directorio de trabajo y puede iniciar la aplicación en R con los mismos comandos que se han usado en este curso.
```{r, eval=F}
library(shiny)
runApp("census-app")
```

---

Shiny tiene tres comandos integrados que facilitan el uso de archivos alojados en línea: `runUrl`, `runGitHub` y `runGist`.

### runUrl 

`runUrl` descarga y lanza una aplicación Shiny directamente desde un enlace web. Para usarlo:

* Guarde el directorio de la aplicación Shiny como un archivo zip.
* Aloje el archivo zip en su propio enlace en una página web. Cualquier usuario con acceso al enlace puede iniciar la aplicación desde R ejecutando:
```{r, eval=F}
library(Shiny)
runUrl("<the weblink>")
```

---

### runGitHub

Si no tiene su propia página web para alojar los archivos, puede alojarlos de forma gratuita en www.github.com. GitHub es un sitio popular para desarrolladores R para el alojamiento de proyectos, ya que hace más que solo alojar archivos. GitHub ofrece muchas funciones para apoyar la colaboración, como rastreadores de problemas, wikis y una estrecha integración con el sistema de control de versiones git. Para usarlo, se debe registrar (es gratis) y elegir un nombre de usuario.

Para compartir una aplicación a través de GitHub, se debe crear un repositorio de proyecto, donde se debe almacenar el archivo `app.R`, junto con el material complementario que use la aplicación. Los usuarios pueden iniciar la aplicación ejecutando:
```{r, eval=F}
runGitHub( "<your repository name>", "<your user name>")
```

---

### runGist

Si se desea publicar archivos en línea en forma anónima, GitHub ofrece un servicio alternativo para compartir archivos en [gist.github.com](https://gist.github.com/), donde no se necesita tener una cuenta GitHub para usar este servicio. Incluso si tiene una cuenta de GitHub, gist es una forma simple y rápida de compartir proyectos Shiny.

Para compartir una aplicación como un gist:

* Copie y pegue el archivo `app.R` en la página web de gist.
* Anote la URL que GitHub le da al gist.

Una vez hecho el gist, los usuarios pueden iniciar la aplicación con `runGist("<gist number>")` donde `"<gist number>"` es el número que aparece al final de la dirección web del Gist.

Un ejemplo de una aplicación alojada como un gist está [aquí](https://gist.github.com/mine-cetinkaya-rundel/eb3470beb1c0252bd0289cbc89bcf36f). Puede iniciar esta aplicación con:
```{r, eval=F}
runGist("eb3470beb1c0252bd0289cbc89bcf36f")
```

## Compartir como una página web

Todos los métodos anteriores comparten la misma limitación, la cual es que requieren que el usuario tenga tanto R como Shiny instalados en su computadora. Sin embargo, Shiny crea la oportunidad perfecta para compartir aplicaciones con personas que no tienen R (y no tienen intención de obtenerlo).

Una aplicación Shiny resulta ser una de las herramientas de comunicación más utilizadas en el mundo, esto es, una página web. Si se aloja la aplicación en una URL propia, los usuarios pueden visitarla (y no deben preocuparse por el código que la genera).

Si se está familiarizado con el alojamiento web o se tiene acceso a un departamento de TI, el propietario puede alojar sus aplicaciones Shiny por si mismo. En el caso contrario, si se prefiere una experiencia más fácil o se necesita asistencia, RStudio le ofrece tres formas de alojar su aplicación Shiny como una página web:

1. shinyapps.io
2. Shiny Server
3. RStudio Connect

---

### Shinyapps.io

La forma más fácil de convertir una aplicación Shiny en una página web es usar `shinyapps.io`, el servicio de alojamiento para aplicaciones Shiny de RStudio, el cual lo deja cargar la aplicación directamente desde una sesión de R.

El propietario tiene el control total sobre la aplicación, incluyendo las herramientas de administración del servidor. Para mayor información visite [shinyapps.io](http://www.shinyapps.io/).

---

### Shiny Server

Shiny Server es un programa complementario de Shiny (gratis, de código abierto y está disponible en GitHub) que crea un servidor web diseñado para alojar aplicaciones Shiny. Shiny server puede ser ejecutado en servidores Linux y puede alojar múltiples aplicaciones Shiny en varias páginas web, y puede implementar las aplicaciones desde detrás de un firewall.

Para ver instrucciones detalladas de cómo instalar y configurar un servidor Shiny, visite la [Guía de Shiny server](https://github.com/rstudio/shiny-server/blob/master/README.md).

---

### RStudio Connect

Si se usa Shiny en un entorno comercial, es posible que sean de interés las herramientas de servidor que vienen con la mayoría de los programas de servidor pagos, tales como:

* Autenticación por contraseña.
* Soporte SSL.
* Herramientas de administrador.
* Soporte prioritario.

En ese caso, [RStudio Connect](https://www.rstudio.com/products/connect/) es una plataforma de publicación para el trabajo en R en un entorno comercial, donde se comparte aplicaciones Shiny, informes en R Markdown, dashboards, gráficas, notas en Jupyter y más en un lugar conveniente. Para mayor información visite [RStudio Connect](https://www.rstudio.com/products/connect/).

## Resumen

Las aplicaciones Shiny son fáciles de compartir, ya sea a través de scripts de R, o como una aplicación web completamente funcional con su propia URL. Cada método tiene sus propias ventajas.

En esta sección se aprendió que:

* Cualquier persona puede lanzar una aplicación siempre y cuando tenga una copia de los archivos de la misma, e instalador tanto R como Shiny.
* `runUrl`, `runGitHub` y `runGist` permiten compartir y recuperar archivos Shiny desde enlaces web.
* [shinyapps.io](http://shinyapps.io/) permite convertir una aplicación Shiny en una aplicación web en vivo con su propia URL.
* Se puede usar programa de código abierto [Shiny server](https://github.com/rstudio/shiny-server/blob/master/README.md) para crear un servidor Linux que aloje aplicaciones Shiny.
* Si se requiere un control más estricto o se desea administrar grandes volúmenes de tráfico, se puede adquirir [RStudio Connect](https://www.rstudio.com/products/connect/) de RStudio.

# Conclusiones del curso

## Conclusiones

Hemos recorrido todo el proceso de desarrollo de Shiny, de forma que podemos crear una aplicación sofisticada y reactiva, implementarla y compartirla con otros.

**El siguiente paso es practicar y luego explorar las características avanzadas de Shiny.**

Para ello, el [Centro de desarrollo de Shiny](http://shiny.rstudio.com/) puede ayudarlo, ya que alberga una [Galería](https://shiny.rstudio.com/gallery/) de aplicaciones inspiradoras, junto con el código que las produce. También incluye una sección de [artículos](https://shiny.rstudio.com/articles/) para educación continua, que examinan en profundidad algunos temas de Shiny de nivel intermedio a avanzado.

# **Ahora que sabes lo suficiente para crear tus propias aplicaciones Shiny. ¡Mira qué puedes hacer!**